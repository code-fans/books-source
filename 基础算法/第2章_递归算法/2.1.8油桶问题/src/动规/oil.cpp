// 	感觉还可以用01背包问题解决。所谓01背包，具体参见动态规划章节，此处简单讲一下：
//设f[i][j]表示用容量为i的背包容纳前j个物品所能得到的最大价值，则01背包问题状态转移方程为f[i][j]＝max{ f[i][j－1]，f[i－cost[j]][j－1]＋val[j]}，其中cost[i]为第i个物品消耗的空间，val[i]为第i个物品的价值。
//意思是用容量i来装j个物品得到的最大价值即f[i][j]为：要么是不装第j个物品即用容量i来装前j－1个物品得到的最大价值(f[i][j－1])；要么是取第j个物品，那么前j－1个物品只能放在i－cost[j]的容量中的最大价值(f[i－cost[j]][j－1])加上第j个物品的价值(val[j])的最大价值。                  f[i][j]取两种选择中的最大值即可。
//　　
//　　借鉴这个思想，现将题目的意思抽象为：判断能否在n个数字中取出一部分，使其和为m，即判断能否在n个物品中选出若干件正好装满容量为m的背包。
//    动态转移方程为：(bool)f[i][j]＝f[i][j－1] || f[i－cost[j]][j－1]，即容量为i的背包能否正好被前j个物品装满(f[i][j])，取决于：
//（1）不取第j个物品，前j－1个物品能否填满容量为i的背包；
//    （2）取第j个物品，前j－1个物品能否填满容量为i－cost[j]的背包；
//    若（1）和（2）有一条满足那么前j个物品就能装满容量为i的背包。
//    边界条件为：f[0][j]＝true，（0≤j≤n）；即无论前几个物品都可以填满容量为0的背包。
//    此外，还可以将二维数组空间压缩至一维。
//参考程序如下所示。

//油桶问题－动规２
#include <iostream>
#include <cstdlib>
using namespace std;

int main()
{
  freopen("oil.in","rb",stdin);
  freopen("oil.out","w",stdout);
  int n,m;
  scanf("%d %d",&n,&m);

  int i,j,cost[n+1];
  for(i=1; i<=n; i++)
    scanf("%d",&cost[i]);

  bool f[m+1];
  for(i=1; i<=m; i++)
    f[i]=0; //清0
  f[0]=1; //f[i][0]=true

  for(j=1; j<=n; j++) //压缩后的类01背包动规
    for(i=m; i>0; i--)
      f[i]=f[i] | ((i-cost[j]>=0) & f[i-cost[j]]);

  printf("%s\n",f[m]?"yes":"no");
  return 0;
}
