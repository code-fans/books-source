//放苹果
//苹果m个，盘子n个。假设 f ( m , n ) 代表 m 个苹果，n个盘子有 f ( m , n ) 种放法。
//根据 n 和 m 的关系可以进一步分析：
//特殊的 n = 1 || m = 1 || n = 0 时只有一种方法
//当 m < n时，即使苹果每个盘子放一个也没法放满所有盘子，题目允许有的盘子空着不放，
//所以我们可以将空盘子去掉，即 f ( m , n ) = f ( m , m )
//当 m >= n时，这时候有两种情况：
//n 个盘子中有一个空盘子，当有空盘子时，f ( m , n ) = f ( m , n - 1 ) ,这时候问题
//出现了，f ( m , n-1 ) 代表的意思是m个苹果放到n-1个盘子中，那还可能有 2 个或者 n
//个空盘子呢，请看后面的解释。
//n个盘子中没有空盘子，当没有空盘子时也就是说每个盘子中至少有一个苹果，先把所有盘
//子填满，这时候会剩下 m - n 个苹果，所以现在问题变成了 m - n 个苹果放在 n 个盘子
//有多少种方法，即 f ( m - n , n )。
//解释 m >= n 时最后的疑问：因为 m >= n , 所以 m >= n - 1 必然成立，也就是说
//f ( m , n - 1 )这个状态也会面临两种情况，即 m >= n 时的 i 和 ii，当面临 i 时可得
// f ( m , n - 1 ) = f ( m , n - 2 )，所以有 2 个空盘子的情况是在 1 个空盘子前就解
// 决了，所以现在只需要考虑 1 个空盘子的情况就好了。
//根据如上所分析，递推关系如下： f( m - n, n) + f( m, n - 1);
#include <bits/stdc++.h>
using namespace std;

int f( int m, int n)
{
  if( m == 1 || n ==1 || m== 0)//如果剩1个盘子 || 没有苹果可以放
    return 1;
  else if( m < n )              //如果盘子多于苹果，相当于去除多余盘子
    return f( m, m);
  else
    return f( m - n, n) + f( m, n - 1);//或者这么考虑：有一个空的或者没有一个空的
}

int main()
{
  //freopen("apple.in","r",stdin);
  //freopen("apple.out","w",stdout);
  int t, m, n;
  cin>>t;
  while( t-- )
  {
    cin>>m>>n;
    cout<<f( m, n)<<endl;
  }
  return 0;
}
