因为请求是有序的，而且同一时刻还只有一个人在移动，显然具有阶段性，而且无后效性。

最直观的做法，可以用 f[i][A][B][C]f[i][A][B][C] 表示处理完请求i之后，三名服务员分别在位置 AA、BB、CC 的最小费用。

转移也不是很难，设第 ii 次请求位置为 xx，那么就有： 
f[i][A][B][x]=min(f[i−1][A][B][C]+cost[C][x])f[i][A][B][x]=min(f[i−1][A][B][C]+cost[C][x]) 
f[i][A][x][C]=min(f[i−1][A][B][C]+cost[B][x])f[i][A][x][C]=min(f[i−1][A][B][C]+cost[B][x]) 
f[i][x][B][C]=min(f[i−1][A][B][C]+cost[A][x])f[i][x][B][C]=min(f[i−1][A][B][C]+cost[A][x])

很遗憾这样的做法既会 MLE 又会 TLE。那么必然要把状态改进一下。

我们结合题意，再观察一下上面的状态转移方程，可以发现，处理完请求 ii 之后，三个服务员中必定有一人在 xx 。

那么，我们为什么要多花一维状态记他呢？？

直接可以记 f[i][A][B]f[i][A][B]，表示处理完请求 ii 之后，三名服务员（无序）分别在位置 AA、BB、xx 的最小费用。

设第 i−1i−1 次请求位置为 yy，于是状态转移方程就变成了： 
f[i][B][C]=dp[i−1][B][C]+c[y][x]f[i][B][C]=dp[i−1][B][C]+c[y][x] 
f[i][B][y]=min(dp[i−1][B][C]+c[C][x])f[i][B][y]=min(dp[i−1][B][C]+c[C][x]) 
f[i][C][y]=min(dp[i−1][B][C]+c[B][x])f[i][C][y]=min(dp[i−1][B][C]+c[B][x])

转移的时候注意，其中 AA、BB、xx 互不相等。

这样交上去几乎就是一个正解，很可惜却只有 95 分。

再来改进。既然 f[i]f[i] 的值只取决于 f[i−1]f[i−1]，显然可以滚动一下。这样就能 AC 了。

最后总结一下这题，其实做 dp 题最重要的还是如何划分阶段，恰当的描述状态，并进行合理的状态优化。
