#include<bits/stdc++.h>
#define debug cout<<"aaa"<<endl
#define d(a) cout<<a<<endl
#define mem(a,b) memset(a,b,sizeof(a))
#define LL long long
#define lson l,mid,root<<1
#define rson mid+1,r,root<<1|1
#define MIN_INT (-2147483647-1)
#define MAX_INT 2147483647
#define MAX_LL 9223372036854775807i64
#define MIN_LL (-9223372036854775807i64-1)
using namespace std;

const int N = 1000000 + 5;
const int mod = 1000000000 + 7;
const double eps = 1e-8;
int dp[10][15][3],DIG[10];

int dfs(int pos,int pre,bool status,bool limit){
	//已搜到尽头，返回"是否找到了答案"这个状态
	if(pos<1){
		return status;
	} 
    //DP里储存的是完整的,也不受限的答案,所以如果满足的话,可以直接返回。
	if(!limit&&dp[pos][pre][status]!=-1){
		return dp[pos][pre][status];
	}
	int end=limit?DIG[pos]:9;
	int ret=0;
	//往下搜的状态表示得很巧妙,status用||是因为如果前面找到了答案
    //那么后面还有没有答案都无所谓了。而limti用&&是因为只有前面受限、当前受限才能
    //推出下一步也受限，比如567,如果是46X的情况,虽然6已经到尽头,但是后面的
    //个位仍然可以随便取,因为百位没受限,所以如果个位要受限,那么前面必须是56。
    //
    //这里用"不要62和4"一题来做例子。
    for(int i=0;i<=end;i++){
    	ret+=dfs(pos-1,i,status||(pre==6&&i==2)||i==4,limit&&(i==end));
    }
    //DP里储存完整的、取到尽头的资料
    if(!limit){
    	dp[pos][pre][status]=ret;
    }
    return ret;
}
//计算出[0-x]有多少个坏数字
int solve(int x){
	mem(dp,-1),mem(DIG,0);
	int p=1;
	while(x){
		DIG[p++]=x%10;
		x/=10;
	}
	p--;
	return dfs(p,-1,0,1);
}

int main(){
	int n,m;
	while(~scanf("%d%d",&n,&m)){
		if(n==0&&m==0){
			break;
		}
		printf("%d\n",(m-n+1)-(solve(m)-solve(n-1)));
	}
	return 0;
}